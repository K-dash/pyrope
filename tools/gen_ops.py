#!/usr/bin/env python3
"""
Operator code generator.

Parses src/ops/kind.rs and generates:
1. src/py/op_generated.rs (Rust Op class)
2. pyrope/__init__.pyi (Python stub Op class)
"""
# ruff: noqa: T201  # Allow print() in this tool

import re
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


@dataclass
class OpParam:
    name: str
    py_type: str
    rust_type: str


@dataclass
class OpSpec:
    name: str
    py_name: str
    in_type: str
    out_type: str
    params: list[OpParam]
    variant_name: str


# Type mapping from Python stub types to Rust types
PY_TO_RUST_TYPE = {
    "str": "String",
    "int": "usize",
}


def parse_kind_rs(path: Path) -> list[OpSpec]:
    """Parse src/ops/kind.rs and extract OpSpec for each variant."""
    content = path.read_text()

    specs = []
    lines = content.split("\n")
    i = 0

    while i < len(lines):
        line = lines[i].strip()

        # Look for doc comments starting with @op
        if line.startswith("/// @op"):
            meta_lines = []
            j = i
            while j < len(lines) and lines[j].strip().startswith("///"):
                meta_lines.append(lines[j].strip()[4:])  # Remove "/// "
                j += 1

            # Next non-comment line should be the variant
            while j < len(lines) and not lines[j].strip():
                j += 1

            if j < len(lines):
                variant_line = lines[j].strip().rstrip(",")
                variant_name = variant_line.split("{")[0].split("(")[0].strip()

                spec = parse_meta(meta_lines, variant_name)
                if spec:
                    specs.append(spec)

                i = j + 1
            else:
                i += 1
        else:
            i += 1

    return specs


def parse_meta(meta_lines: list[str], variant_name: str) -> Optional[OpSpec]:
    """Parse meta information from doc comments."""
    name = None
    py_name = None
    in_type = None
    out_type = None
    params = []

    for line in meta_lines:
        line = line.strip()

        # @op name=foo py=bar
        if line.startswith("@op "):
            parts = line[4:].split()
            for part in parts:
                if "=" in part:
                    key, value = part.split("=", 1)
                    if key == "name":
                        name = value
                    elif key == "py":
                        py_name = value

        # @sig in=Type out=Type
        elif line.startswith("@sig "):
            # Extract in= and out= values more carefully
            # in= value is everything between "in=" and " out="
            # out= value is everything after "out="
            if " in=" in line and " out=" in line:
                in_start = line.index(" in=") + 4
                out_start = line.index(" out=")
                in_type = line[in_start:out_start].strip()
                out_type = line[out_start + 5 :].strip()
            elif line.startswith("@sig in="):
                # Handle case where in= is first
                if " out=" in line:
                    parts = line[9:].split(" out=")
                    in_type = parts[0].strip()
                    out_type = parts[1].strip()
                else:
                    in_type = line[9:].strip()

        # @param name:type
        elif line.startswith("@param "):
            param_str = line[7:].strip()
            if ":" in param_str:
                param_name, py_type = param_str.split(":", 1)
                rust_type = PY_TO_RUST_TYPE.get(py_type, py_type)
                params.append(OpParam(param_name, py_type, rust_type))

    if name and py_name and in_type and out_type:
        return OpSpec(name, py_name, in_type, out_type, params, variant_name)

    return None


def generate_rust_op(specs: list[OpSpec]) -> str:
    """Generate src/py/op_generated.rs content."""
    lines = [
        "// This file is auto-generated by tools/gen_ops.py",
        "// Do not edit manually!",
        "",
        "use crate::ops::OperatorKind;",
        "use crate::py::operator::Operator;",
        "use pyo3::prelude::*;",
        "",
        "/// Static factory class for creating Operators",
        '#[pyclass(frozen, name = "Op")]',
        "pub struct Op;",
        "",
        "#[pymethods]",
        "impl Op {",
    ]

    for i, spec in enumerate(specs):
        # Method signature
        param_list = ", ".join(f"{p.name}: {p.rust_type}" for p in spec.params)

        lines.append("    #[staticmethod]")
        lines.append(f"    pub fn {spec.py_name}({param_list}) -> Operator {{")

        # Method body
        if not spec.params:
            lines.append(f"        Operator {{")
            lines.append(f"            kind: OperatorKind::{spec.variant_name},")
            lines.append(f"        }}")
        else:
            # Pass params to OperatorKind
            param_init = ", ".join(f"{p.name}" for p in spec.params)
            lines.append(f"        Operator {{")
            lines.append(f"            kind: OperatorKind::{spec.variant_name} {{ {param_init} }},")
            lines.append(f"        }}")

        lines.append("    }")
        # Only add blank line between methods, not after the last one
        if i < len(specs) - 1:
            lines.append("")

    lines.append("}")

    return "\n".join(lines)


def generate_python_stub(specs: list[OpSpec]) -> str:
    """Generate the Op class stub content for __init__.pyi."""
    # Generate content without any indentation
    # The replacement will preserve the original indentation
    lines = []
    lines.append("# BEGIN GENERATED OP")

    for spec in specs:
        # Method signature
        param_list = ", ".join(f"{p.name}: {p.py_type}" for p in spec.params)

        lines.append("@staticmethod")
        lines.append(
            f"def {spec.py_name}({param_list}) -> Operator[{spec.in_type}, {spec.out_type}]: ..."
        )

    lines.append("# END GENERATED OP")

    return "\n".join(lines)


def update_python_stub(pyi_path: Path, new_content: str):
    """Update pyrope/__init__.pyi with new Op stub content."""
    content = pyi_path.read_text()

    # Find and replace between markers, preserving indentation
    begin = "# BEGIN GENERATED OP"
    end = "# END GENERATED OP"

    # Match with any leading whitespace before the begin marker
    pattern = re.compile(
        rf"^(\s*)({re.escape(begin)}).*?({re.escape(end)})",
        re.MULTILINE | re.DOTALL
    )

    match = pattern.search(content)
    if not match:
        raise ValueError(f"Markers not found in {pyi_path}")

    # Get the indentation from the matched begin marker
    indent = match.group(1)
    
    # Apply the same indentation to all lines in new_content
    indented_lines = []
    for line in new_content.split("\n"):
        if line.strip():  # Non-empty line
            indented_lines.append(indent + line)
        else:
            indented_lines.append("")
    
    indented_content = "\n".join(indented_lines)
    
    # Replace the match
    updated = pattern.sub(indented_content, content)
    pyi_path.write_text(updated)


def main():
    """Main entry point."""
    root = Path(__file__).parent.parent
    kind_rs = root / "src/ops/kind.rs"
    op_generated_rs = root / "src/py/op_generated.rs"
    pyi = root / "pyrope/__init__.pyi"

    print(f"ğŸ“– Parsing {kind_rs}...")
    specs = parse_kind_rs(kind_rs)
    print(f"   Found {len(specs)} operators")

    print(f"ğŸ¦€ Generating {op_generated_rs}...")
    rust_code = generate_rust_op(specs)
    # Ensure trailing newline
    if not rust_code.endswith("\n"):
        rust_code += "\n"
    op_generated_rs.write_text(rust_code)

    print(f"ğŸ Updating {pyi}...")
    stub_content = generate_python_stub(specs)
    update_python_stub(pyi, stub_content)

    print("âœ… Done!")


if __name__ == "__main__":
    main()
